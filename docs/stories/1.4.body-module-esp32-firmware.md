# Story 1.4: Body Module ESP32 Firmware - Heart Animation

## Status
Draft

## Story
**As a** firmware developer,
**I want** ESP32 firmware rendering emotion-driven heart animation,
**so that** I can validate I2C + SPI communication with a beating heart display.

## Acceptance Criteria

1. **Development Environment:**
   - PlatformIO project: `modules/body/firmware/`
   - Libraries: `TFT_eSPI` or `Adafruit_GC9A01A`, `Wire.h`

2. **I2C Slave Implementation:**
   - ESP32 configured as I2C slave at address **0x0A**
   - I2C receive/request handlers implemented

3. **I2C Register Map (Body Module 0x0A):**
   - `0x00`: Module ID (returns 0x0A)
   - `0x02`: Status byte (READY/BUSY/ERROR)
   - `0x10`: Emotion type (0=neutral, 1=happy, 2=excited, 3=sad, 4=curious, 5=thinking, 6=confused)
   - `0x11`: Emotion intensity (1-5, affects beat amplitude)
   - `0x12`: Heart rate override (BPM, 0=auto from emotion)
   - `0x13-0x15`: Heart color (RGB, 0-255 each)

4. **Heart Animation Engine:**
   - Heart sprite (240×240 display, centered)
   - Beating animation: Scale/pulse effect synchronized to BPM
   - **Emotion-to-BPM mapping:**
     - Neutral: 60-70 BPM | Happy: 80-90 BPM | Excited: 100-120 BPM
     - Sad: 50-60 BPM | Curious: 70-80 BPM | Thinking: 65-75 BPM | Confused: 75-85 BPM
   - Intensity: 1=subtle (10% scale), 5=dramatic (50% scale)
   - Color variations: red=default, blue=sad, yellow=happy
   - 60 FPS smooth animation

5. **Testing:**
   - Firmware compiled and uploaded
   - Serial: "I2C Slave initialized at 0x0A"
   - Heart beats at 70 BPM (neutral) on startup
   - Responsive to I2C commands via `i2cset`

6. **Performance:**
   - 60 FPS maintained
   - I2C latency <10ms
   - Memory stable over 10 minutes

7. **Code Quality:**
   - Files: `main.cpp`, `heart_animation.cpp`, `gc9a01_driver_spi.cpp`, `i2c_slave.cpp`
   - Comments explain I2C protocol
   - Code committed to `modules/body/firmware/`

## Tasks / Subtasks

- [ ] **Task 1: Set up PlatformIO project for body module** (AC: 1)
  - [ ] Create `modules/body/firmware/` directory structure
  - [ ] Initialize PlatformIO with `platformio.ini` configuration
  - [ ] Add required libraries: TFT_eSPI or Adafruit_GC9A01A, Wire.h
  - [ ] Configure build environment for ESP32-S3-WROOM-2 or ESP32-WROOM-32

- [ ] **Task 2: Implement I2C slave communication** (AC: 2, 3)
  - [ ] Create `i2c_slave.cpp/h` implementing I2C slave at address 0x0A
  - [ ] Implement register map: Module ID (0x00), Status (0x02), Emotion type (0x10), Intensity (0x11), Heart rate (0x12), RGB color (0x13-0x15)
  - [ ] Implement I2C receive/request interrupt handlers
  - [ ] Add thread-safe data exchange between I2C ISR and main loop

- [ ] **Task 3: Develop GC9A01 SPI driver** (AC: 4)
  - [ ] Create `gc9a01_driver_spi.cpp/h` for round TFT display
  - [ ] Configure SPI interface (GPIO18=SCK, GPIO23=MOSI, GPIO4=RST, GPIO2=DC, GPIO5=CS)
  - [ ] Implement initialization sequence for GC9A01
  - [ ] Implement drawing primitives (filled circle, sprite rendering)
  - [ ] Optimize for 10-20 MHz SPI speed

- [ ] **Task 4: Create heart animation engine** (AC: 4)
  - [ ] Create `heart_animation.cpp/h` with animation state machine
  - [ ] Implement heart sprite rendering (240×240 centered)
  - [ ] Implement scale/pulse animation synchronized to BPM
  - [ ] Implement emotion-to-BPM mapping (neutral=60-70, happy=80-90, excited=100-120, sad=50-60, curious=70-80, thinking=65-75, confused=75-85)
  - [ ] Implement intensity mapping to scale amplitude (1=10%, 5=50%)
  - [ ] Implement color variation logic (red=default, blue=sad, yellow=happy)
  - [ ] Achieve 60 FPS rendering with smooth frame timing

- [ ] **Task 5: Implement main controller loop** (AC: 1, 2, 4, 5)
  - [ ] Create `main.cpp` integrating all components
  - [ ] Initialize I2C slave, SPI display, animation engine
  - [ ] Implement main loop reading I2C commands and updating animation
  - [ ] Add serial logging for initialization and command reception
  - [ ] Set default state: neutral emotion, 70 BPM heartbeat

- [ ] **Task 6: Test firmware functionality** (AC: 5, 6)
  - [ ] Compile and upload firmware to ESP32
  - [ ] Verify serial output: "I2C Slave initialized at 0x0A"
  - [ ] Test I2C communication with `i2cdetect -y 1` (device at 0x0A)
  - [ ] Test emotion changes via `i2cset` commands
  - [ ] Verify 60 FPS performance (measure frame timing)
  - [ ] Test I2C latency (<10ms response time)
  - [ ] Run 10-minute stability test (memory leak detection)

- [ ] **Task 7: Code cleanup and documentation** (AC: 7)
  - [ ] Add comments explaining I2C protocol and register map
  - [ ] Document pin assignments in code header
  - [ ] Create module README with wiring diagram and usage instructions
  - [ ] Commit code to `modules/body/firmware/`

## Dev Notes

### Previous Story Insights
From Story 1.3 (Body Module - Heart LCD Hardware Assembly):
- Hardware is assembled with GC9A01 display connected via SPI (GPIO18=SCK, GPIO23=MOSI, GPIO4=RST, GPIO2=DC, GPIO5=CS)
- I2C wiring established (Pi GPIO2/3 to ESP32 GPIO21/22)
- Body module configured as I2C slave at address 0x0A
- SPI target speed: 10-20 MHz for 60 FPS animation
- Power supplied via USB power bank or bench supply (5V)

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Firmware Development:**
- **Language:** C/C++ (C++17 standard)
- **Build Tool:** PlatformIO 6.1+
- **MCU:** ESP32-S3-WROOM-2 (N8R8) or ESP32-WROOM-32 (Xtensa LX7 dual-core @ 240MHz, 512KB SRAM)
- **Display:** GC9A01 Round TFT Display (1.28", 240×240, SPI interface, 65K colors)
- **I2C Library:** Wire.h (Arduino core, interrupt support)
- **Display Library:** TFT_eSPI or Adafruit_GC9A01A

**Communication:**
- **I2C:** 400kHz-1MHz, address 0x0A (Body module)
- **SPI:** 10-20 MHz for 60 FPS animation

### Data Models
[Source: docs/architecture/data-models.md]

**I2C Register Map - Standard Registers (All Modules):**
```cpp
#define REG_MODULE_ID           0x00  // Read-only: Module identification
#define REG_FIRMWARE_VERSION    0x01  // Read-only: Firmware version
#define REG_STATUS              0x02  // Read-only: Module status byte
#define REG_ERROR_CODE          0x03  // Read-only: Last error code
#define REG_COMMAND             0x04  // Write: Command trigger

// Status byte bit flags
#define STATUS_READY            0x01
#define STATUS_BUSY             0x02
#define STATUS_ERROR            0x04
```

**Body Module Specific Registers:**
- `0x10`: Emotion type (0-6: neutral, happy, excited, sad, curious, thinking, confused)
- `0x11`: Emotion intensity (1-5)
- `0x12`: Heart rate override (BPM, 0=auto from emotion)
- `0x13-0x15`: Heart color RGB (0-255 each)

**Expression Types:**
```cpp
#define EXPR_NEUTRAL  0x00
#define EXPR_HAPPY    0x01
#define EXPR_EXCITED  0x02  // Note: Different order than head module
#define EXPR_SAD      0x03
#define EXPR_CURIOUS  0x04
#define EXPR_THINKING 0x05
#define EXPR_CONFUSED 0x06
```

### Component Specifications
[Source: docs/architecture/components.md#body-module]

**Body Module Responsibilities:**
- Heart LCD display with emotion-driven heartbeat animation
- 60 FPS animation rendering (240×240 round TFT eyes)
- Heart color variations for emotional states (red=default, blue=sad, yellow=happy)
- Coordinated with personality system via I2C

**Hardware:**
- ESP32-S3-WROOM-2 (N8R8: 32MB Flash, 8MB PSRAM)
- 1× GC9A01 Round TFT Display (1.28", 240×240, SPI)

**Firmware Architecture:**
```
body_controller.ino
├── i2c_slave.cpp
├── heart_animation.cpp
├── gc9a01_driver_spi.cpp    // Round TFT driver (240×240)
```

**I2C Address:** 0x0A

### File Locations
[Source: docs/architecture/source-tree.md#modules-esp32-firmware-cc]

**Module Firmware Structure:**
```
modules/body/                  # Body Module (I2C 0x0A)
├── firmware/
│   ├── body_controller.ino
│   ├── gc9a01_driver_spi.cpp/h  # Heart LCD driver
│   ├── heart_animation.cpp/h    # 60 FPS heart animation
│   └── config.h
├── platformio.ini
└── README.md
```

**Key Paths:**
- Firmware code: `modules/body/firmware/`
- PlatformIO config: `modules/body/platformio.ini`
- Module documentation: `modules/body/README.md`

### Coding Standards
[Source: docs/architecture/coding-standards.md#c-standards-esp32-firmware]

**C++ Naming Conventions:**
- Classes/Structs: `PascalCase` (e.g., `AnimationEngine`, `I2CSlave`)
- Functions: `camelCase` (e.g., `expressEmotion()`, `readSensorData()`)
- Variables: `snake_case` (e.g., `target_angle_deg`, `i2c_buffer`)
- Constants: `kPascalCase` or `UPPER_SNAKE_CASE` (e.g., `kMaxServoAngle`, `I2C_SLAVE_ADDRESS`)
- Private members: `trailing_underscore_` (e.g., `servo_position_`)

**File Organization:**
- Header files: `.h` extension with `#pragma once`
- Implementation files: `.cpp` extension
- Arduino sketches: `.ino` extension

**Memory Management:**
- ❌ NEVER use dynamic allocation in real-time loops (malloc, new)
- ✅ Use fixed-size arrays or pre-allocate during setup()
- ✅ Check available heap with `ESP.getFreeHeap()` during development

**Timing:**
- NEVER use `delay()` in time-critical code
- Use `millis()` for non-blocking timing
- Document timing requirements in comments (e.g., "Must execute in <5ms")

**I2C Slave Interrupt Handling:**
- Keep interrupt handlers SHORT (<10 microseconds)
- Set flags, don't process - defer work to main loop
- Use `volatile` for shared variables between ISR and main code

Example pattern:
```cpp
volatile bool i2c_command_received = false;
volatile uint8_t i2c_command_buffer[16];

void onI2CReceive(int num_bytes) {
  // ISR - keep minimal!
  for (int i = 0; i < num_bytes && i < 16; i++) {
    i2c_command_buffer[i] = Wire.read();
  }
  i2c_command_received = true;  // Set flag, return FAST
}

void loop() {
  if (i2c_command_received) {
    processI2CCommand(i2c_command_buffer);  // Process in main loop
    i2c_command_received = false;
  }
}
```

**Error Handling:**
- Use serial logging with levels: `[DEBUG]`, `[INFO]`, `[WARN]`, `[ERROR]`
- Include module name and context in logs
- Fail-safe behaviors: Enter safe mode on hardware init failures

**Configuration Constants:**
```cpp
// Body module configuration
constexpr uint8_t kI2CSlaveAddress = 0x0A;
constexpr uint16_t kDisplayWidth = 240;
constexpr uint16_t kDisplayHeight = 240;
constexpr uint32_t kTargetFPS = 60;
constexpr uint32_t kFrameTimeMs = 1000 / kTargetFPS;  // ~16ms
```

### Testing

[Source: docs/architecture/coding-standards.md#testing-standards]

**Testing Framework:** Arduino Unit Test (PlatformIO integration)

**Test Location:** `modules/body/test/`

**Test Files:**
- `test_heart_animation.cpp` - Heart animation logic
- `test_i2c_slave.cpp` - I2C command parsing

**Hardware-in-the-Loop Tests:**
- Validate timing with oscilloscope or logic analyzer
- I2C command response latency (<10ms)
- Animation frame rate consistency (60 FPS ±5%)
- Memory stability (no heap fragmentation over 10 minutes)

**Required Tests:**
- I2C command parsing (valid/invalid commands)
- Animation frame rate consistency (60 FPS)
- Emotion-to-BPM mapping correctness
- Intensity scaling (1-5 maps to 10%-50% amplitude)
- Color variation logic

**Running Tests:**
```bash
# Build firmware
pio run -d modules/body

# Upload to ESP32
pio run -d modules/body -t upload

# Run unit tests (if applicable)
pio test -d modules/body
```

**Manual Testing Procedure:**
1. Flash firmware to ESP32
2. Connect to serial monitor (115200 baud)
3. Verify initialization message: "I2C Slave initialized at 0x0A"
4. Run `sudo i2cdetect -y 1` on Pi - verify device at 0x0A
5. Send test commands:
   - `sudo i2cset -y 1 0x0A 0x10 0x01` (set happy emotion)
   - `sudo i2cset -y 1 0x0A 0x11 0x03` (set intensity 3)
6. Observe heart animation change (BPM increase, color shift)
7. Monitor serial output for any errors
8. Run for 10 minutes, verify no memory leaks

### Technical Constraints

**Performance Requirements:**
- 60 FPS animation (16.67ms per frame)
- I2C response latency <10ms
- Memory stable (no leaks over extended runtime)

**Hardware Constraints:**
- SPI speed: 10-20 MHz for smooth 60 FPS rendering
- I2C speed: 400kHz-1MHz
- Display resolution: 240×240 pixels (round GC9A01)

**Power Constraints:**
- Temporary power: USB power bank or bench supply (5V)
- ESP32 + display power consumption should be monitored

## Dev Agent Record

### Agent Model Used
<!-- To be filled by dev agent -->

### Debug Log References
<!-- To be filled by dev agent -->

### Completion Notes List
<!-- To be filled by dev agent -->

### File List
<!-- To be filled by dev agent -->

## QA Results
<!-- To be filled by QA agent -->

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | v1.0 | Initial story draft | Bob (Scrum Master) |
