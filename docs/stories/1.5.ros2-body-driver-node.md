# Story 1.5: ROS2 Body Driver Node - I2C Bridge

## Status
Draft

## Story
**As a** software developer,
**I want** a ROS2 node that translates ROS2 topics into I2C register writes,
**so that** the orchestrator can control the heart display without knowing I2C details.

## Acceptance Criteria

1. **Node Structure:**
   - Python ROS2 node: `orchestrator/ros2_nodes/hardware_drivers/body_driver.py`
   - Node name: `/olaf/body_driver`
   - Uses `rclpy` and `smbus2`

2. **I2C Communication:**
   - Opens I2C bus 1: `bus = SMBus(1)`
   - Helper functions for register read/write to address 0x0A

3. **ROS2 Subscriptions:**
   - `/olaf/body/emotion` (custom msg: emotion_type, intensity)
   - Callback writes to registers 0x10-0x11
   - `/olaf/body/heart_color` (std_msgs/ColorRGBA)
   - Callback writes to registers 0x13-0x15

4. **ROS2 Publications:**
   - `/olaf/body/status` (std_msgs/String) at 10Hz
   - Reads status register 0x02, publishes "READY", "BUSY", or "ERROR"

5. **Module Health Check:**
   - On startup: Read register 0x00, verify response is 0x0A
   - If not responding: Log error, publish ERROR status

6. **Error Handling:**
   - I2C timeout handling
   - Retry logic: 3 attempts with 100ms delay
   - Persistent failure: Publish ERROR

7. **Testing:**
   - Node launches: `ros2 run olaf_drivers body_driver`
   - Topics appear: `/olaf/body/emotion`, `/olaf/body/status`
   - Manual test: Publish emotion → heart changes BPM

## Tasks / Subtasks

- [ ] **Task 1: Set up ROS2 package structure** (AC: 1)
  - [ ] Create `orchestrator/ros2_nodes/hardware_drivers/` directory if not exists
  - [ ] Create `body_driver.py` with proper ROS2 node boilerplate
  - [ ] Add dependencies: `rclpy`, `smbus2`, `std_msgs`
  - [ ] Configure node name: `/olaf/body_driver`

- [ ] **Task 2: Implement I2C communication layer** (AC: 2)
  - [ ] Initialize SMBus(1) for I2C bus access
  - [ ] Create helper function `write_register(address, register, value)`
  - [ ] Create helper function `read_register(address, register)`
  - [ ] Add error handling for I2C bus access failures

- [ ] **Task 3: Implement module health check** (AC: 5)
  - [ ] On node startup, read register 0x00 from address 0x0A
  - [ ] Verify response is 0x0A (module ID)
  - [ ] Log initialization success/failure
  - [ ] Set internal health status flag

- [ ] **Task 4: Create ROS2 subscribers** (AC: 3)
  - [ ] Subscribe to `/olaf/body/emotion` (create custom message or use dict)
  - [ ] Implement callback to write emotion_type to register 0x10
  - [ ] Implement callback to write intensity to register 0x11
  - [ ] Subscribe to `/olaf/body/heart_color` (std_msgs/ColorRGBA)
  - [ ] Implement callback to write RGB to registers 0x13-0x15

- [ ] **Task 5: Create ROS2 publisher for status** (AC: 4)
  - [ ] Create publisher `/olaf/body/status` (std_msgs/String)
  - [ ] Create 10Hz timer callback
  - [ ] Read status register 0x02 in timer callback
  - [ ] Map status byte to string: "READY"/"BUSY"/"ERROR"
  - [ ] Publish status message

- [ ] **Task 6: Implement error handling and retry logic** (AC: 6)
  - [ ] Wrap I2C operations in try-except blocks
  - [ ] Implement 3-attempt retry with 100ms delay
  - [ ] Log errors with context (register, value, attempt number)
  - [ ] On persistent failure, publish ERROR status
  - [ ] Implement graceful degradation (continue operation, mark module offline)

- [ ] **Task 7: Test node functionality** (AC: 7)
  - [ ] Launch node: `ros2 run olaf_drivers body_driver`
  - [ ] Verify topics with `ros2 topic list`
  - [ ] Test emotion command: `ros2 topic pub /olaf/body/emotion ...`
  - [ ] Verify heart display changes (observe BPM/color shift)
  - [ ] Monitor status topic: `ros2 topic echo /olaf/body/status`
  - [ ] Test error handling (disconnect ESP32, verify ERROR status)

- [ ] **Task 8: Documentation and code quality** (AC: 1, 7)
  - [ ] Add docstrings to all functions
  - [ ] Add comments explaining I2C register mappings
  - [ ] Document node in `orchestrator/ros2_nodes/README.md`
  - [ ] Commit code to repository

## Dev Notes

### Previous Story Insights
From Story 1.4 (Body Module ESP32 Firmware):
- Firmware implements I2C slave at address 0x0A
- Register map: 0x00=Module ID, 0x02=Status, 0x10=Emotion type, 0x11=Intensity, 0x12=Heart rate, 0x13-0x15=RGB color
- Firmware responds to I2C commands with <10ms latency
- Heart animation updates at 60 FPS based on received emotion/intensity

From Story 1.2 (Raspberry Pi ROS2 Setup):
- ROS2 Humble installed on Pi
- I2C enabled on /dev/i2c-1
- smbus2 library installed for Python I2C communication
- User added to i2c group for permissions

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Orchestrator:**
- **Language:** Python 3.11+
- **ROS2 Version:** Humble (LTS until 2027)
- **I2C Library:** smbus2 0.4.x (Python I2C communication)
- **Build Tool:** colcon (ROS2 standard)

**Communication:**
- **Module Communication:** I2C at 400kHz-1MHz
- **I2C Latency:** 5-20ms expected, <100ms required

### ROS2 Node Architecture
[Source: docs/architecture/ros2-node-architecture.md]

**Hardware Driver Nodes Pattern:**
- All ROS2 nodes run on Raspberry Pi only
- Driver nodes act as I2C bridges between ROS2 topics and ESP32 modules
- ESP32s are smart I2C slave peripherals (NOT ROS2 nodes)

**Body Driver Node:**
```
/olaf/body_driver (Python + smbus2)
• I2C Address: 0x0A
• Subscribes: /olaf/body/emotion, /olaf/body/heart_color
• Publishes: /olaf/body/status
```

**Intelligence Distribution:**
- **Raspberry Pi:** High-level commands (emotion type, intensity)
- **ESP32:** Hardware control (SPI display rendering, animation engine, 60 FPS timing)

### Data Models
[Source: docs/architecture/data-models.md]

**I2C Register Map - Body Module (0x0A):**
```cpp
// Standard registers
#define REG_MODULE_ID           0x00  // Read-only: Returns 0x0A
#define REG_FIRMWARE_VERSION    0x01  // Read-only: Firmware version
#define REG_STATUS              0x02  // Read-only: Module status byte
#define REG_ERROR_CODE          0x03  // Read-only: Last error code
#define REG_COMMAND             0x04  // Write: Command trigger

// Body module specific
#define REG_EMOTION_TYPE        0x10  // 0-6: neutral, happy, excited, sad, curious, thinking, confused
#define REG_EMOTION_INTENSITY   0x11  // 1-5
#define REG_HEART_RATE_BPM      0x12  // 0=auto, or override BPM
#define REG_HEART_COLOR_R       0x13  // Red channel 0-255
#define REG_HEART_COLOR_G       0x14  // Green channel 0-255
#define REG_HEART_COLOR_B       0x15  // Blue channel 0-255

// Status byte bit flags
#define STATUS_READY            0x01
#define STATUS_BUSY             0x02
#define STATUS_ERROR            0x04
```

**ROS2 Custom Messages (if needed):**
```python
# olaf_msgs/msg/Expression.msg
string emotion              # 'happy', 'curious', etc.
uint8 intensity             # 1-5
uint8 duration_ms
bool synchronize
```

### File Locations
[Source: docs/architecture/source-tree.md#orchestrator-raspberry-pi-software-pythonros2]

**Orchestrator Structure:**
```
orchestrator/
├── ros2_nodes/
│   ├── hardware_drivers/  # I2C driver nodes (one per module)
│   │   ├── head_driver_node.py
│   │   ├── ears_neck_driver_node.py
│   │   ├── body_driver_node.py    # <-- THIS STORY
│   │   └── base_driver_node.py
│   ├── personality/
│   ├── ai_integration/
│   └── navigation/
├── launch/
├── config/
│   ├── ros2_params.yaml
│   └── module_i2c_addresses.yaml
├── requirements.txt
└── README.md
```

**Key Paths:**
- Node file: `orchestrator/ros2_nodes/hardware_drivers/body_driver.py`
- ROS2 parameters: `orchestrator/config/ros2_params.yaml`
- I2C addresses config: `orchestrator/config/module_i2c_addresses.yaml`

### Coding Standards
[Source: docs/architecture/coding-standards.md#python-standards-ros2-orchestrator]

**Python Style (PEP 8 + ROS2):**
- **Line Length:** 100 characters maximum
- **Classes:** `PascalCase` (e.g., `BodyDriverNode`)
- **Functions/methods:** `snake_case` (e.g., `write_register()`)
- **Constants:** `UPPER_SNAKE_CASE` (e.g., `I2C_BODY_ADDRESS`)
- **Private members:** `_leading_underscore`

**Type Hints:**
- Required for all public functions
- Use modern syntax: `list[int]` not `List[int]`

**Docstrings:**
- Required for all public classes, functions, modules
- Format: Google style
- Include: Purpose, parameters, return values, exceptions

**Error Handling:**
- Catch specific exceptions, not bare `except:`
- Log with context using ROS2 logger
- Fail gracefully - degrade functionality, don't crash

Example:
```python
try:
    value = self._i2c_client.read_byte_data(I2C_BODY_ADDRESS, REG_STATUS)
except IOError as e:
    self.get_logger().warning(
        f"Body module I2C timeout reading status register, using cached value"
    )
    value = self._last_status
```

**Logging:**
- Use `self.get_logger()` in ROS2 nodes
- Levels: DEBUG (verbose), INFO (state changes), WARNING (recoverable errors), ERROR (unrecoverable)
- Include units in log messages

**ROS2-Specific:**
- **Node Naming:** `<module>_<function>_node` (e.g., `body_driver_node`)
- **Namespace:** All nodes under `/olaf/` (e.g., `/olaf/body_driver`)
- **Topic Naming:** `/<namespace>/<module>/<data_type>` (e.g., `/olaf/body/emotion`)
- **Parameter Naming:** `<module>.<parameter>` (e.g., `body.i2c_address`)

**Async/Await:**
- Use for I2C operations to prevent blocking ROS2 event loop
- Timeout all async operations (never indefinite waits)

### Testing

[Source: docs/architecture/coding-standards.md#testing-standards]

**Framework:** pytest 7.4+

**Test Organization:**
- **Location:** `tests/unit/orchestrator/hardware_drivers/`
- **Naming:** `test_body_driver.py`
- **Structure:** One test class per production class

**Coverage Target:** 70%+ for critical paths

**Required Tests:**
- I2C communication (with mocked hardware using fixtures)
- Timeout/failure scenarios
- Retry logic (3 attempts with 100ms delay)
- Status mapping (STATUS_READY → "READY")
- Topic subscriptions and callbacks

**Integration Tests:**
- Hardware-in-the-loop test with actual ESP32
- Measure I2C latency (<100ms from publish to heart update)

**Running Tests:**
```bash
# Unit tests (mocked I2C)
pytest tests/unit/orchestrator/hardware_drivers/test_body_driver.py

# Integration test (requires hardware)
pytest tests/integration/test_i2c_communication.py
```

**Manual Testing Procedure:**
1. Ensure ESP32 body module powered and running firmware (Story 1.4)
2. Source ROS2: `source /opt/ros/humble/setup.bash`
3. Launch node: `ros2 run olaf_drivers body_driver`
4. Verify topics: `ros2 topic list | grep /olaf/body`
5. Echo status: `ros2 topic echo /olaf/body/status` (should show "READY")
6. Send test emotion:
   ```bash
   ros2 topic pub --once /olaf/body/emotion std_msgs/msg/String "data: 'happy'"
   ```
7. Observe heart display (BPM should increase, color might shift)
8. Test error handling: Power off ESP32, verify "ERROR" status published

### Technical Constraints

**Performance Requirements:**
- I2C operations should complete within 100ms total (including retries)
- Status publication at 10Hz (100ms period)
- Node should not block ROS2 event loop

**Error Handling Requirements:**
- 3 retry attempts with 100ms delay between attempts
- Graceful degradation: Continue operating even if module offline
- Clear error logging with context

**Thread Safety:**
- ROS2 callbacks may run concurrently
- Protect shared I2C bus access with locks if multiple modules accessed
- Use atomic operations for status flags

## Dev Agent Record

### Agent Model Used
<!-- To be filled by dev agent -->

### Debug Log References
<!-- To be filled by dev agent -->

### Completion Notes List
<!-- To be filled by dev agent -->

### File List
<!-- To be filled by dev agent -->

## QA Results
<!-- To be filled by QA agent -->

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | v1.0 | Initial story draft | Bob (Scrum Master) |
