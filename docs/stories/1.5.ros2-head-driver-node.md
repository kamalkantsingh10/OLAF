# Story 1.5: ROS2 Head Driver Node - I2C Bridge

## Status
In Progress

## Story
**As a** software developer,
**I want** a ROS2 node that translates ROS2 topics into I2C register writes,
**so that** the orchestrator can control the eye displays without knowing I2C details.

## Acceptance Criteria

1. **Node Structure:**
   - Python ROS2 node: `ros2/src/orchestrator/ros2_nodes/hardware_drivers/head_driver.py`
   - Node name: `/olaf/head_driver`
   - Uses `rclpy` and `smbus2`

2. **I2C Communication:**
   - Opens I2C bus 1: `bus = SMBus(1)`
   - Helper functions for register read/write to address 0x08

3. **ROS2 Subscriptions:**
   - `/olaf/head/expression` (custom msg: expression_type, intensity)
   - Callback writes to registers 0x10-0x11
   - `/olaf/head/blink` (std_msgs/Empty)
   - Callback writes to register 0x12

4. **ROS2 Publications:**
   - `/olaf/head/status` (std_msgs/String) at 10Hz
   - Reads status register 0x02, publishes "READY", "BUSY", or "ERROR"

5. **Module Health Check:**
   - On startup: Read register 0x00, verify response is 0x08
   - If not responding: Log error, publish ERROR status

6. **Error Handling:**
   - I2C timeout handling
   - Retry logic: 3 attempts with 100ms delay
   - Persistent failure: Publish ERROR

7. **Testing:**
   - Node launches: `ros2 run orchestrator head_driver`
   - Topics appear: `/olaf/head/expression`, `/olaf/head/status`
   - Manual test: Publish expression → eyes change expression

## Tasks / Subtasks

- [x] **Task 1: Set up ROS2 package structure** (AC: 1)
  - [x] Create `ros2/src/orchestrator/ros2_nodes/hardware_drivers/` directory if not exists
  - [x] Create `head_driver.py` with proper ROS2 node boilerplate
  - [x] Add dependencies: `rclpy`, `smbus2`, `std_msgs`
  - [x] Configure node name: `/olaf/head_driver`

- [x] **Task 2: Implement I2C communication layer** (AC: 2)
  - [x] Initialize SMBus(1) for I2C bus access
  - [x] Create helper function `write_register(address, register, value)`
  - [x] Create helper function `read_register(address, register)`
  - [x] Add error handling for I2C bus access failures

- [x] **Task 3: Implement module health check** (AC: 5)
  - [x] On node startup, read register 0x00 from address 0x08
  - [x] Verify response is 0x08 (module ID)
  - [x] Log initialization success/failure
  - [x] Set internal health status flag

- [x] **Task 4: Create ROS2 subscribers** (AC: 3)
  - [x] Subscribe to `/olaf/head/expression` (create custom message or use dict)
  - [x] Implement callback to write expression_type to register 0x10
  - [x] Implement callback to write intensity to register 0x11
  - [x] Subscribe to `/olaf/head/blink` (std_msgs/Empty)
  - [x] Implement callback to write to register 0x12 (blink trigger)

- [x] **Task 5: Create ROS2 publisher for status** (AC: 4)
  - [x] Create publisher `/olaf/head/status` (std_msgs/String)
  - [x] Create 10Hz timer callback
  - [x] Read status register 0x02 in timer callback
  - [x] Map status byte to string: "READY"/"BUSY"/"ERROR"
  - [x] Publish status message

- [x] **Task 6: Implement error handling and retry logic** (AC: 6)
  - [x] Wrap I2C operations in try-except blocks
  - [x] Implement 3-attempt retry with 100ms delay
  - [x] Log errors with context (register, value, attempt number)
  - [x] On persistent failure, publish ERROR status
  - [x] Implement graceful degradation (continue operation, mark module offline)

- [ ] **Task 7: Test node functionality** (AC: 7)
  - [ ] Launch node: `ros2 run orchestrator head_driver`
  - [ ] Verify topics with `ros2 topic list`
  - [ ] Test expression command: `ros2 topic pub /olaf/head/expression ...`
  - [ ] Verify eye displays change (observe expression shift)
  - [ ] Test blink command: `ros2 topic pub /olaf/head/blink std_msgs/Empty`
  - [ ] Monitor status topic: `ros2 topic echo /olaf/head/status`
  - [ ] Test error handling (disconnect ESP32, verify ERROR status)

- [x] **Task 8: Documentation and code quality** (AC: 1, 7)
  - [x] Add docstrings to all functions
  - [x] Add comments explaining I2C register mappings
  - [ ] Document node in `ros2/src/orchestrator/ros2_nodes/README.md`
  - [ ] Commit code to repository

## Dev Notes

### Previous Story Insights
From Story 1.4 (Head Module ESP32 Firmware):
- Firmware implements I2C slave at address 0x08
- Register map: 0x00=Module ID, 0x02=Status, 0x10=Expression type, 0x11=Intensity, 0x12=Blink trigger
- Firmware responds to I2C commands with <10ms latency
- Eye expressions update at 60 FPS based on received expression/intensity

From Story 1.2 (Raspberry Pi ROS2 Setup):
- ROS2 Humble installed on Pi
- I2C enabled on /dev/i2c-1
- smbus2 library installed for Python I2C communication
- User added to i2c group for permissions

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Orchestrator:**
- **Language:** Python 3.11+
- **ROS2 Version:** Humble (LTS until 2027)
- **I2C Library:** smbus2 0.4.x (Python I2C communication)
- **Build Tool:** colcon (ROS2 standard)

**Communication:**
- **Module Communication:** I2C at 400kHz-1MHz
- **I2C Latency:** 5-20ms expected, <100ms required

### ROS2 Node Architecture
[Source: docs/architecture/ros2-node-architecture.md]

**Hardware Driver Nodes Pattern:**
- All ROS2 nodes run on Raspberry Pi only
- Driver nodes act as I2C bridges between ROS2 topics and ESP32 modules
- ESP32s are smart I2C slave peripherals (NOT ROS2 nodes)

**Head Driver Node:**
```
/olaf/head_driver (Python + smbus2)
• I2C Address: 0x08
• Subscribes: /olaf/head/expression, /olaf/head/blink
• Publishes: /olaf/head/status
```

**Intelligence Distribution:**
- **Raspberry Pi:** High-level commands (expression type, intensity, blink trigger)
- **ESP32:** Hardware control (dual SPI display rendering, animation engine, 60 FPS timing)

### Data Models
[Source: docs/architecture/data-models.md]

**I2C Register Map - Head Module (0x08):**
```cpp
// Standard registers
#define REG_MODULE_ID           0x00  // Read-only: Returns 0x08
#define REG_FIRMWARE_VERSION    0x01  // Read-only: Firmware version
#define REG_STATUS              0x02  // Read-only: Module status byte
#define REG_ERROR_CODE          0x03  // Read-only: Last error code
#define REG_COMMAND             0x04  // Write: Command trigger

// Head module specific
#define REG_EXPRESSION_TYPE     0x10  // 0-6: neutral, happy, curious, thinking, confused, sad, excited
#define REG_EXPRESSION_INTENSITY 0x11 // 1-5
#define REG_BLINK_TRIGGER       0x12  // Write any value to trigger blink

// Status byte bit flags
#define STATUS_READY            0x01
#define STATUS_BUSY             0x02
#define STATUS_ERROR            0x04
```

**ROS2 Custom Messages (if needed):**
```python
# interfaces/msg/Expression.msg
string emotion              # 'happy', 'curious', etc.
uint8 intensity             # 1-5
uint8 duration_ms
bool synchronize
```

### File Locations
[Source: docs/architecture/source-tree.md#orchestrator-raspberry-pi-software-pythonros2]

**Orchestrator Structure:**
```
orchestrator/
├── ros2_nodes/
│   ├── hardware_drivers/  # I2C driver nodes (one per module)
│   │   ├── head_driver_node.py    # <-- THIS STORY
│   │   ├── ears_neck_driver_node.py
│   │   ├── body_driver_node.py
│   │   └── base_driver_node.py
│   ├── personality/
│   ├── ai_integration/
│   └── navigation/
├── launch/
├── config/
│   ├── ros2_params.yaml
│   └── module_i2c_addresses.yaml
├── requirements.txt
└── README.md
```

**Key Paths:**
- Node file: `ros2/src/orchestrator/ros2_nodes/hardware_drivers/head_driver.py`
- ROS2 parameters: `ros2/src/orchestrator/config/ros2_params.yaml`
- I2C addresses config: `ros2/src/orchestrator/config/module_i2c_addresses.yaml`

### Coding Standards
[Source: docs/architecture/coding-standards.md#python-standards-ros2-orchestrator]

**Python Style (PEP 8 + ROS2):**
- **Line Length:** 100 characters maximum
- **Classes:** `PascalCase` (e.g., `HeadDriverNode`)
- **Functions/methods:** `snake_case` (e.g., `write_register()`)
- **Constants:** `UPPER_SNAKE_CASE` (e.g., `I2C_HEAD_ADDRESS`)
- **Private members:** `_leading_underscore`

**Type Hints:**
- Required for all public functions
- Use modern syntax: `list[int]` not `List[int]`

**Docstrings:**
- Required for all public classes, functions, modules
- Format: Google style
- Include: Purpose, parameters, return values, exceptions

**Error Handling:**
- Catch specific exceptions, not bare `except:`
- Log with context using ROS2 logger
- Fail gracefully - degrade functionality, don't crash

Example:
```python
try:
    value = self._i2c_client.read_byte_data(I2C_HEAD_ADDRESS, REG_STATUS)
except IOError as e:
    self.get_logger().warning(
        f"Head module I2C timeout reading status register, using cached value"
    )
    value = self._last_status
```

**Logging:**
- Use `self.get_logger()` in ROS2 nodes
- Levels: DEBUG (verbose), INFO (state changes), WARNING (recoverable errors), ERROR (unrecoverable)
- Include units in log messages

**ROS2-Specific:**
- **Node Naming:** `<module>_<function>_node` (e.g., `head_driver_node`)
- **Namespace:** All nodes under `/olaf/` (e.g., `/olaf/head_driver`)
- **Topic Naming:** `/<namespace>/<module>/<data_type>` (e.g., `/olaf/head/expression`)
- **Parameter Naming:** `<module>.<parameter>` (e.g., `head.i2c_address`)

**Async/Await:**
- Use for I2C operations to prevent blocking ROS2 event loop
- Timeout all async operations (never indefinite waits)

### Testing

[Source: docs/architecture/coding-standards.md#testing-standards]

**Framework:** pytest 7.4+

**Test Organization:**
- **Location:** `tests/unit/orchestrator/hardware_drivers/`
- **Naming:** `test_head_driver.py`
- **Structure:** One test class per production class

**Coverage Target:** 70%+ for critical paths

**Required Tests:**
- I2C communication (with mocked hardware using fixtures)
- Timeout/failure scenarios
- Retry logic (3 attempts with 100ms delay)
- Status mapping (STATUS_READY → "READY")
- Topic subscriptions and callbacks
- Blink trigger handling

**Integration Tests:**
- Hardware-in-the-loop test with actual ESP32
- Measure I2C latency (<100ms from publish to eye update)

**Running Tests:**
```bash
# Unit tests (mocked I2C)
pytest tests/unit/orchestrator/hardware_drivers/test_head_driver.py

# Integration test (requires hardware)
pytest tests/integration/test_i2c_communication.py
```

**Manual Testing Procedure:**
1. Ensure ESP32 head module powered and running firmware (Story 1.4)
2. Source ROS2: `source /opt/ros/humble/setup.bash`
3. Launch node: `ros2 run orchestrator head_driver`
4. Verify topics: `ros2 topic list | grep /olaf/head`
5. Echo status: `ros2 topic echo /olaf/head/status` (should show "READY")
6. Send test expression:
   ```bash
   ros2 topic pub --once /olaf/head/expression std_msgs/msg/String "data: 'happy'"
   ```
7. Observe eye displays (expression should change to happy)
8. Send blink command:
   ```bash
   ros2 topic pub --once /olaf/head/blink std_msgs/msg/Empty
   ```
9. Observe synchronized blink animation
10. Test error handling: Power off ESP32, verify "ERROR" status published

### Technical Constraints

**Performance Requirements:**
- I2C operations should complete within 100ms total (including retries)
- Status publication at 10Hz (100ms period)
- Node should not block ROS2 event loop

**Error Handling Requirements:**
- 3 retry attempts with 100ms delay between attempts
- Graceful degradation: Continue operating even if module offline
- Clear error logging with context

**Thread Safety:**
- ROS2 callbacks may run concurrently
- Protect shared I2C bus access with locks if multiple modules accessed
- Use atomic operations for status flags

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None

### Completion Notes List
- Implemented complete ROS2 head driver node with I2C bridge functionality
- Added extensive inline comments and comprehensive docstrings per coding standards
- Implemented 3-attempt retry logic with 100ms delay for I2C operations
- Created health check on startup (reads module ID register)
- Status publisher at 10Hz with graceful error handling
- Expression callback supports "emotion,intensity" format with defaults
- All error handling includes context logging as per coding standards
- Testing (Task 7) remains incomplete - requires hardware and ROS2 build

### File List
- Created: `ros2/src/orchestrator/ros2_nodes/__init__.py`
- Created: `ros2/src/orchestrator/ros2_nodes/hardware_drivers/__init__.py`
- Created: `ros2/src/orchestrator/ros2_nodes/hardware_drivers/head_driver.py`
- Modified: `docs/stories/1.5.ros2-head-driver-node.md` (task checkboxes, status, Dev Agent Record)

## QA Results
<!-- To be filled by QA agent -->

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | v1.0 | Initial story draft | Bob (Scrum Master) |
| 2025-10-25 | v1.1 | Updated from body to head driver, I2C 0x08, expression topics | Bob (Scrum Master) |
