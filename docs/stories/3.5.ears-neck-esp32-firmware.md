# Story 3.5: Ears+Neck ESP32 Firmware - Servo Control & Kinematics

## Status
Draft

## Story
**As a** firmware developer,
**I want** ESP32 firmware controlling 7 servos (4 ears + 3 neck) with coordinated kinematics,
**so that** the orchestrator can command natural head gestures and ear expressions.

## Acceptance Criteria

1. **Development Environment:**
   - PlatformIO project: `firmware/ears_neck/firmware/`
   - Platform: ESP32-S3 (Arduino framework)
   - Libraries: `Wire.h` (I2C), `HardwareSerial.h` (UART), Feetech servo library (SCS/STS compatible)

2. **I2C Slave Implementation:**
   - ESP32 configured as I2C slave at address **0x09**
   - I2C receive/request handlers implemented
   - Interrupt-driven I2C communication

3. **I2C Register Map (Ears+Neck Module 0x09):**
   - `0x00`: Module ID (returns 0x09)
   - `0x02`: Status byte (READY/BUSY/ERROR)
   - **Ear Control Registers:**
     - `0x10`: Left ear horizontal position (0-180°, maps to -60° to +60°)
     - `0x11`: Left ear vertical position (0-180°, maps to -45° to +45°)
     - `0x12`: Right ear horizontal position (0-180°, maps to -60° to +60°)
     - `0x13`: Right ear vertical position (0-180°, maps to -45° to +45°)
   - **Neck Control Registers:**
     - `0x20`: Neck pan position (0-180°, maps to -90° to +90°)
     - `0x21`: Neck tilt position (0-180°, maps to -45° to +45°)
     - `0x22`: Neck roll position (0-180°, maps to -30° to +30°)
   - **Coordinated Gesture Register:**
     - `0x30`: Gesture ID (0=neutral, 1=look-left, 2=look-right, 3=nod-yes, 4=shake-no, 5=tilt-curious, 6=alert-ears-up)
     - `0x31`: Gesture speed (1=slow, 5=fast)
     - `0x32`: Gesture trigger (write any value to start gesture)

4. **Dual UART Servo Communication:**
   - **UART1 (GPIO4 TX, GPIO5 RX):** Ear servo controller (Servos 1-4)
   - **UART2 (GPIO16 TX, GPIO17 RX):** Neck servo controller (Servos 5-7)
   - Servo library initialized for both buses
   - Position commands sent to servos in degrees (0-180° or servo-specific range)

5. **Kinematics Engine:**
   - **Ear Positioning:**
     - Independent control: Each ear's 2-DOF position calculated from horizontal/vertical inputs
     - Coordinated modes: Both ears mirror (symmetrical) or asymmetric (one forward, one back)
   - **Neck Kinematics:**
     - Forward kinematics: Pan, tilt, roll → final head orientation
     - Combined movements: Smooth interpolation when multiple axes change simultaneously

6. **Coordinated Gestures:**
   - Predefined gesture sequences combining ears + neck:
     - **neutral:** Ears centered, neck level
     - **look-left:** Pan -60°, left ear forward, right ear back
     - **look-right:** Pan +60°, right ear forward, left ear back
     - **nod-yes:** Tilt down -20° → up +10° → center (repeat 2×)
     - **shake-no:** Pan left -30° → right +30° → center (repeat 2×)
     - **tilt-curious:** Roll 15°, tilt up 20°, ears asymmetric
     - **alert-ears-up:** Both ears vertical +45°, neck level
   - Gestures execute asynchronously (non-blocking I2C communication)
   - Status register shows BUSY during gesture, READY when complete

7. **Motion Profiles:**
   - Smooth acceleration/deceleration (easing functions)
   - Speed control: Gesture speed register (1-5) adjusts movement duration (500ms-2s)
   - Simultaneous servo updates: All servos start movement together for coordinated gestures

8. **Testing:**
   - Firmware compiled and uploaded to ESP32-S3
   - Serial: "I2C Slave initialized at 0x09 - Ears+Neck Module"
   - I2C scan: `sudo i2cdetect -y 1` shows device at 0x09
   - Manual ear test: Write to 0x10-0x13 → ears move to positions
   - Manual neck test: Write to 0x20-0x22 → neck moves to positions
   - Gesture test: Write gesture ID 1, trigger 0x32 → executes look-left gesture
   - All 7 servos responsive, smooth motion, no jitter

9. **Performance:**
   - I2C latency: <10ms from command received to servo movement started
   - Gesture execution time: 500ms-2s (speed-dependent)
   - Memory stable over 30 minutes continuous operation
   - No servo overheating (thermal check after 10 minutes of movement)

10. **Code Quality:**
    - Files:
      - `main.cpp`
      - `i2c_slave.cpp`
      - `ear_servo_controller.cpp` (UART1, servos 1-4)
      - `neck_servo_controller.cpp` (UART2, servos 5-7)
      - `kinematics.cpp` (coordinate transformations)
      - `coordinated_gestures.cpp` (predefined gesture sequences)
      - `motion_profiles.cpp` (easing functions)
    - Comments explain dual-UART architecture and gesture coordination
    - Code committed to `firmware/ears_neck/firmware/`

## Tasks / Subtasks

- [ ] **Task 1: Setup PlatformIO project** (AC: 1)
  - [ ] Create project: `firmware/ears_neck/firmware/`
  - [ ] Configure platformio.ini:
    - [ ] Platform: espressif32
    - [ ] Board: esp32-s3-devkitc-1
    - [ ] Framework: arduino
  - [ ] Add libraries:
    - [ ] Wire.h (built-in I2C)
    - [ ] HardwareSerial.h (built-in UART)
    - [ ] Feetech servo library (SCS/STS protocol)
  - [ ] Create source files structure

- [ ] **Task 2: Implement I2C slave** (AC: 2, 3)
  - [ ] Create `i2c_slave.cpp`:
    - [ ] Configure I2C slave at address 0x09
    - [ ] Use GPIO21 (SDA), GPIO22 (SCL)
    - [ ] Implement receive handler (I2C write from master)
    - [ ] Implement request handler (I2C read from master)
  - [ ] Define register map (0x00-0x32)
  - [ ] Implement register read/write logic
  - [ ] Test: `sudo i2cdetect -y 1` shows 0x09

- [ ] **Task 3: Implement dual UART servo communication** (AC: 4)
  - [ ] Create `ear_servo_controller.cpp`:
    - [ ] Initialize UART1 (GPIO4 TX, GPIO5 RX)
    - [ ] Configure baud rate (115200 or servo default)
    - [ ] Implement position command to servos 1-4
    - [ ] Implement servo ID addressing (1, 2, 3, 4)
  - [ ] Create `neck_servo_controller.cpp`:
    - [ ] Initialize UART2 (GPIO16 TX, GPIO17 RX)
    - [ ] Configure baud rate (115200 or servo default)
    - [ ] Implement position command to servos 5-7
    - [ ] Implement servo ID addressing (5, 6, 7)
  - [ ] Test: Send UART commands, verify servos move

- [ ] **Task 4: Implement ear kinematics** (AC: 5)
  - [ ] Create `kinematics.cpp`:
    - [ ] Function: `setEarPosition(ear_id, horizontal, vertical)`
    - [ ] Map 0-180° input to servo-specific ranges:
      - [ ] Horizontal: -60° to +60°
      - [ ] Vertical: -45° to +45°
    - [ ] Send position commands to UART1 (ear controller)
  - [ ] Test: Write to I2C registers 0x10-0x13, verify ears move

- [ ] **Task 5: Implement neck kinematics** (AC: 5)
  - [ ] Add to `kinematics.cpp`:
    - [ ] Function: `setNeckPosition(pan, tilt, roll)`
    - [ ] Map 0-180° input to servo-specific ranges:
      - [ ] Pan: -90° to +90°
      - [ ] Tilt: -45° to +45°
      - [ ] Roll: -30° to +30°
    - [ ] Send position commands to UART2 (neck controller)
  - [ ] Test: Write to I2C registers 0x20-0x22, verify neck moves

- [ ] **Task 6: Implement coordinated gestures** (AC: 6)
  - [ ] Create `coordinated_gestures.cpp`:
    - [ ] Define gesture struct: positions[], duration
    - [ ] Implement gestures:
      - [ ] Gesture 0: neutral (ears centered, neck level)
      - [ ] Gesture 1: look-left (pan -60°, left ear forward, right ear back)
      - [ ] Gesture 2: look-right (pan +60°, right ear forward, left ear back)
      - [ ] Gesture 3: nod-yes (tilt sequence)
      - [ ] Gesture 4: shake-no (pan sequence)
      - [ ] Gesture 5: tilt-curious (roll + tilt + asymmetric ears)
      - [ ] Gesture 6: alert-ears-up (both ears vertical, neck level)
    - [ ] Function: `executeGesture(gesture_id, speed)`
    - [ ] Asynchronous execution (non-blocking main loop)
  - [ ] Test: Write gesture ID to 0x30, trigger 0x32, verify execution

- [ ] **Task 7: Implement motion profiles** (AC: 7)
  - [ ] Create `motion_profiles.cpp`:
    - [ ] Easing functions: ease-in-out, linear, ease-in, ease-out
    - [ ] Speed mapping: 1=2000ms, 2=1500ms, 3=1000ms, 4=700ms, 5=500ms
    - [ ] Interpolation: Calculate intermediate positions for smooth movement
  - [ ] Apply easing to gesture movements
  - [ ] Test: Execute gesture at different speeds (1-5)

- [ ] **Task 8: Implement status management** (AC: 3, 6)
  - [ ] Add status byte logic:
    - [ ] READY (0x01): Idle, no gesture executing
    - [ ] BUSY (0x02): Gesture in progress
    - [ ] ERROR (0x04): Servo communication failure
  - [ ] Update status during gesture execution
  - [ ] I2C register 0x02 returns current status
  - [ ] Test: Read status before/during/after gesture

- [ ] **Task 9: Integration and testing** (AC: 8)
  - [ ] Create `main.cpp`:
    - [ ] Initialize I2C slave (0x09)
    - [ ] Initialize UART1 (ears) and UART2 (neck)
    - [ ] Main loop: Process I2C commands, update gestures
    - [ ] Serial logging for debugging
  - [ ] Upload firmware to ESP32-S3
  - [ ] Verify serial output: "I2C Slave initialized at 0x09"
  - [ ] I2C test: `sudo i2cdetect -y 1` shows 0x09
  - [ ] Manual tests:
    - [ ] Ear positions (registers 0x10-0x13)
    - [ ] Neck positions (registers 0x20-0x22)
    - [ ] Gestures (registers 0x30-0x32)
  - [ ] All 7 servos responsive

- [ ] **Task 10: Performance and stability testing** (AC: 9)
  - [ ] I2C latency test: Measure time from write to servo movement (<10ms)
  - [ ] Gesture timing test: Verify speed control (500ms-2s range)
  - [ ] Memory stability: Run for 30 minutes, monitor free heap
  - [ ] Thermal test: 10 minutes continuous movement, check servo temperatures
  - [ ] No jitter, smooth motion verified

- [ ] **Task 11: Code cleanup and documentation** (AC: 10)
  - [ ] Add comments to all functions
  - [ ] Document I2C register map in code
  - [ ] Document UART1/UART2 pin assignments
  - [ ] Update `firmware/ears_neck/README.md`:
    - [ ] Build instructions
    - [ ] I2C register map reference
    - [ ] UART servo wiring
    - [ ] Gesture definitions
  - [ ] Commit code to repository

## Dev Notes

### Prerequisites
From Story 3.3 (Ear Servo Assembly):
- 4 ear servos (IDs 1-4) assembled and wired to controller
- Ear servo controller connected to ESP32 UART1

From Story 3.4 (Neck Gimbal Assembly):
- 3 neck servos (IDs 5-7) assembled and wired to controller
- Neck servo controller connected to ESP32 UART2
- Ears+Neck Module PCB assembled with dual UART connections

### Feetech Servo Library

**Servo Protocol:**
- Feetech SCS/STS servos use proprietary serial protocol
- Half-duplex UART (single wire for TX/RX or separate TX/RX wires)
- Common commands:
  - Position write: ID, length, command, position_low, position_high, checksum
  - Position read: Request current position from servo

**Library Options:**
- Feetech official library (if available)
- SCServo library (Arduino-compatible)
- Custom implementation (refer to Feetech protocol documentation)

**UART Configuration:**
- Baud rate: 1000000 bps (typical for Feetech servos, verify with datasheet)
- Data format: 8N1 (8 data bits, no parity, 1 stop bit)

### I2C Register Map Details

**Module Identification (Read-Only):**
| Register | Value | Description |
|----------|-------|-------------|
| 0x00 | 0x09 | Module ID (Ears+Neck) |
| 0x01 | 0x01 | Firmware version |

**Status & Control:**
| Register | Bits | Description |
|----------|------|-------------|
| 0x02 | 0x01 | READY flag |
| 0x02 | 0x02 | BUSY flag |
| 0x02 | 0x04 | ERROR flag |

**Ear Control (Write):**
| Register | Range | Maps To | Servo |
|----------|-------|---------|-------|
| 0x10 | 0-180 | -60° to +60° | Servo 1 (left horizontal) |
| 0x11 | 0-180 | -45° to +45° | Servo 2 (left vertical) |
| 0x12 | 0-180 | -60° to +60° | Servo 3 (right horizontal) |
| 0x13 | 0-180 | -45° to +45° | Servo 4 (right vertical) |

**Neck Control (Write):**
| Register | Range | Maps To | Servo |
|----------|-------|---------|-------|
| 0x20 | 0-180 | -90° to +90° | Servo 5 (pan) |
| 0x21 | 0-180 | -45° to +45° | Servo 6 (tilt) |
| 0x22 | 0-180 | -30° to +30° | Servo 7 (roll) |

**Gesture Control:**
| Register | Range | Description |
|----------|-------|-------------|
| 0x30 | 0-6 | Gesture ID |
| 0x31 | 1-5 | Gesture speed (1=slow, 5=fast) |
| 0x32 | any | Trigger (write to start gesture) |

### Gesture Definitions

**Gesture 0: Neutral**
```cpp
ears: [90, 90, 90, 90]  // All centered
neck: [90, 90, 90]       // Pan/tilt/roll all centered
```

**Gesture 1: Look Left**
```cpp
ears: [120, 100, 70, 90]  // Left forward-up, right back
neck: [30, 90, 90]         // Pan -60°, tilt/roll centered
```

**Gesture 2: Look Right**
```cpp
ears: [70, 90, 120, 100]  // Right forward-up, left back
neck: [150, 90, 90]        // Pan +60°, tilt/roll centered
```

**Gesture 3: Nod Yes (sequence)**
```cpp
Step 1: neck tilt 70° (down)  - 300ms
Step 2: neck tilt 100° (up)   - 300ms
Step 3: neck tilt 90° (center) - 200ms
Repeat 2×
```

**Gesture 4: Shake No (sequence)**
```cpp
Step 1: neck pan 60° (left)   - 300ms
Step 2: neck pan 120° (right) - 300ms
Step 3: neck pan 90° (center) - 200ms
Repeat 2×
```

**Gesture 5: Tilt Curious**
```cpp
ears: [120, 110, 90, 90]  // Left forward-up, right centered
neck: [70, 110, 105]       // Pan -20°, tilt +20°, roll +15°
```

**Gesture 6: Alert Ears Up**
```cpp
ears: [90, 135, 90, 135]  // Both ears vertical +45°
neck: [90, 90, 90]         // Neck level (all centered)
```

### Motion Profile Implementation

**Ease-In-Out Function (Cubic):**
```cpp
float easeInOutCubic(float t) {
  return t < 0.5
    ? 4 * t * t * t
    : 1 - pow(-2 * t + 2, 3) / 2;
}
```

**Interpolation Example:**
```cpp
void moveServo(uint8_t servo_id, uint16_t target_pos, uint16_t duration_ms) {
  uint16_t start_pos = getCurrentPosition(servo_id);
  uint32_t start_time = millis();

  while (millis() - start_time < duration_ms) {
    float progress = (float)(millis() - start_time) / duration_ms;
    float eased = easeInOutCubic(progress);
    uint16_t current_pos = start_pos + (target_pos - start_pos) * eased;

    setServoPosition(servo_id, current_pos);
    delay(20);  // 50Hz update rate
  }
}
```

### Testing

**I2C Communication Test:**
```bash
# Test module detection
sudo i2cdetect -y 1  # Should show 0x09

# Test ear position (left horizontal to 120°)
sudo i2cset -y 1 0x09 0x10 120

# Test neck pan (to -60° = value 30)
sudo i2cset -y 1 0x09 0x20 30

# Test gesture (look-left, speed 3)
sudo i2cset -y 1 0x09 0x30 1    # Gesture ID 1
sudo i2cset -y 1 0x09 0x31 3    # Speed 3
sudo i2cset -y 1 0x09 0x32 1    # Trigger gesture
```

**Servo Test (via UART):**
- Use serial monitor to send test commands
- Verify each servo ID (1-7) responds individually
- Check for smooth motion, no stuttering

**Troubleshooting:**
- **Servo not moving:** Check UART wiring, verify baud rate, check servo ID
- **Jerky movement:** Reduce update rate, check power supply voltage
- **I2C not detected:** Verify GPIO21/22, check common ground
- **Gesture doesn't complete:** Check BUSY flag clearing, verify motion profile timing

### File Locations

```
firmware/ears_neck/
├── firmware/
│   ├── src/
│   │   ├── main.cpp                       # <-- THIS STORY
│   │   ├── i2c_slave.cpp                  # <-- THIS STORY
│   │   ├── ear_servo_controller.cpp       # <-- THIS STORY
│   │   ├── neck_servo_controller.cpp      # <-- THIS STORY
│   │   ├── kinematics.cpp                 # <-- THIS STORY
│   │   ├── coordinated_gestures.cpp       # <-- THIS STORY
│   │   └── motion_profiles.cpp            # <-- THIS STORY
│   ├── include/
│   │   └── config.h                       # Pin assignments, constants
│   └── platformio.ini                     # <-- THIS STORY
└── README.md                              # <-- THIS STORY (update)
```

## Dev Agent Record

### Agent Model Used
<!-- To be filled by dev agent -->

### Debug Log References
<!-- To be filled by dev agent -->

### Completion Notes List
<!-- To be filled by dev agent -->

### File List
<!-- To be filled by dev agent -->

## QA Results
<!-- To be filled by QA agent -->

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-08 | v1.0 | Initial story creation from Epic 3 | Sarah (Product Owner) |
