# Story 3.6: Head Module ESP32 Firmware Enhancement - Presence Sensor Integration

## Status
Draft

## Story
**As a** firmware developer,
**I want** Epic 1 Head Module firmware enhanced with mmWave presence sensor integration,
**so that** Olaf can detect human presence and react accordingly.

## Acceptance Criteria

1. **Existing Firmware Base:**
   - Start from Epic 1 `firmware/head/firmware/main.cpp`
   - Existing dual-eye expression engine remains functional
   - I2C slave at address 0x08 remains operational

2. **Presence Sensor Driver:**
   - DFRobot SEN0395 library integrated or custom driver implemented
   - GPIO16 configured for digital presence detection (HIGH = presence, LOW = no presence)
   - Optional: UART configuration for advanced settings (detection range, sensitivity)

3. **I2C Register Map Enhancement (Head Module 0x08):**
   - Existing registers from Epic 1 maintained:
     - `0x00`: Module ID (0x08)
     - `0x02`: Status
     - `0x10`: Expression type
     - `0x11`: Expression intensity
     - `0x12`: Blink trigger
   - **New presence detection registers:**
     - `0x20`: Presence status (0=none, 1=detected)
     - `0x21`: Presence duration (seconds, 0-255)
     - `0x22`: Detection event count (increments on new presence)

4. **Presence Detection Logic:**
   - Poll sensor at 20Hz (50ms interval)
   - Debouncing: Presence must be stable for 200ms to register as detected
   - Duration tracking: Count seconds while presence continuously detected
   - Event counting: Increment counter on rising edge (absence → presence transition)

5. **Autonomous Reactions (Optional Enhancement):**
   - When presence detected after absence: Trigger automatic blink (eyes respond to person entering)
   - Configurable via register 0x23 (autonomous mode: 0=off, 1=on)
   - This creates "awareness" behavior without orchestrator command

6. **Testing:**
   - Firmware compiled and uploaded
   - Serial: "Presence sensor initialized on GPIO16"
   - No presence: Register 0x20 reads 0
   - Person approaches: Register 0x20 reads 1, duration increments
   - Person leaves: Presence status returns to 0, event count incremented
   - Existing eye expressions still functional (Epic 1 tests pass)
   - I2C communication stable with new registers

7. **Integration Testing:**
   - Combined test: Send expression command while presence detected → both work simultaneously
   - Autonomous blink test: Enable 0x23, approach sensor → eyes blink automatically
   - Performance: 60 FPS eye animation maintained while presence polling runs

8. **Code Quality:**
   - Files:
     - `main.cpp` (updated with presence sensor)
     - `presence_sensor.cpp` (new driver)
     - Existing: `eye_expression.cpp`, `gc9a01_driver_spi.cpp`, `i2c_slave.cpp`
   - Comments explain presence detection logic and debouncing
   - Code committed to `firmware/head/firmware/`

## Tasks / Subtasks

- [ ] **Task 1: Understand DFRobot SEN0395 interface** (AC: 2)
  - [ ] Review SEN0395 datasheet
  - [ ] Identify interface modes: Digital OUT, UART control
  - [ ] Determine configuration needs (detection range, sensitivity)
  - [ ] Decide: Digital-only or UART configuration

- [ ] **Task 2: Implement presence sensor driver** (AC: 2, 4)
  - [ ] Create `presence_sensor.cpp`:
    - [ ] Initialize GPIO16 as digital input
    - [ ] Optional: Initialize UART (GPIO17/18) for configuration
    - [ ] Function: `bool readPresence()` - returns current state
    - [ ] Function: `void configureSensor()` - UART config (optional)
  - [ ] Test: Read GPIO16, verify toggles with presence

- [ ] **Task 3: Implement presence detection logic** (AC: 4)
  - [ ] Add debouncing logic:
    - [ ] Sample GPIO16 at 20Hz (50ms timer)
    - [ ] State must be stable for 200ms (4 samples) to confirm
  - [ ] Add duration tracking:
    - [ ] Increment duration counter every second while presence detected
    - [ ] Reset duration to 0 when presence lost
  - [ ] Add event counting:
    - [ ] Detect rising edge (LOW → HIGH transition)
    - [ ] Increment event counter on each rising edge
  - [ ] Test: Verify debouncing, duration, event count

- [ ] **Task 4: Extend I2C register map** (AC: 3)
  - [ ] Update `i2c_slave.cpp`:
    - [ ] Add register 0x20: Presence status (read-only)
    - [ ] Add register 0x21: Presence duration (read-only)
    - [ ] Add register 0x22: Event count (read-only)
    - [ ] Add register 0x23: Autonomous mode (read/write)
  - [ ] Implement register read handlers
  - [ ] Implement register write handler for 0x23
  - [ ] Test: Read registers via i2cget

- [ ] **Task 5: Implement autonomous reactions** (AC: 5)
  - [ ] Add autonomous blink logic:
    - [ ] When presence detected (rising edge)
    - [ ] If autonomous mode enabled (0x23 = 1)
    - [ ] Trigger automatic blink (write to register 0x12 internally)
  - [ ] Test: Enable autonomous mode, approach sensor, verify eyes blink

- [ ] **Task 6: Update main loop** (AC: 1)
  - [ ] Integrate presence sensor polling (20Hz)
  - [ ] Ensure non-blocking (doesn't interfere with eye rendering)
  - [ ] Update I2C register values (0x20-0x22) in main loop
  - [ ] Test: Verify 60 FPS eye rendering maintained

- [ ] **Task 7: Backward compatibility testing** (AC: 6)
  - [ ] Verify Epic 1 functionality:
    - [ ] All 7 eye expressions render correctly
    - [ ] Blink command (0x12) works
    - [ ] Expression intensity (0x11) works
    - [ ] I2C communication latency <10ms
  - [ ] New presence registers don't interfere with existing functionality

- [ ] **Task 8: Integration testing** (AC: 7)
  - [ ] Combined test: Change expression while presence detected
  - [ ] Performance test: Monitor FPS while presence polling active
  - [ ] Autonomous test: Enable mode, approach/leave multiple times
  - [ ] Stress test: Rapid presence changes, verify debouncing

- [ ] **Task 9: Code cleanup and documentation** (AC: 8)
  - [ ] Add comments to presence sensor code
  - [ ] Document debouncing algorithm
  - [ ] Document I2C register map changes
  - [ ] Update `firmware/head/README.md`:
    - [ ] Presence sensor GPIO16 pinout
    - [ ] New I2C registers (0x20-0x23)
    - [ ] Autonomous mode usage
  - [ ] Commit code to repository

## Dev Notes

### Prerequisites
From Epic 1 Story 1.4 (Head Module Firmware):
- Firmware renders 7 emotions on dual GC9A01 displays at 60 FPS
- I2C slave at address 0x08 functional
- Existing register map: 0x00 (ID), 0x02 (status), 0x10-0x12 (expressions)

From Story 3.2 (Head Module PCB):
- DFRobot SEN0395 physically mounted and wired to GPIO16
- Optional UART wired to GPIO17/18 for advanced configuration

### DFRobot SEN0395 Specifications

**Sensor Type:** mmWave (millimeter wave) radar
- **Frequency:** 5.8 GHz
- **Detection Range:** 2-9 meters (configurable)
- **Detection Angle:** 60° cone
- **Response Time:** <1 second
- **Power:** 3.3-5V, <100mA
- **Interfaces:** Digital OUT (presence/no presence), UART (configuration)

**Digital OUT Pin:**
- HIGH (3.3V) = Presence detected
- LOW (0V) = No presence
- Transitions can be noisy (requires debouncing)

**UART Configuration (Optional):**
- Baud rate: 115200
- Commands: Set detection range, sensitivity, delay time
- Example: Set range to 5 meters, sensitivity to medium

### Presence Detection Algorithm

**Debouncing Strategy:**
```cpp
// Sample at 20Hz (every 50ms)
#define SAMPLE_INTERVAL_MS 50
#define DEBOUNCE_SAMPLES 4  // 200ms = 4 samples

uint8_t sample_buffer[DEBOUNCE_SAMPLES] = {0};
uint8_t sample_index = 0;

bool readDebouncedPresence() {
  // Read current state
  bool current = digitalRead(GPIO_PRESENCE);

  // Update circular buffer
  sample_buffer[sample_index] = current ? 1 : 0;
  sample_index = (sample_index + 1) % DEBOUNCE_SAMPLES;

  // Check if all samples agree
  uint8_t sum = 0;
  for (int i = 0; i < DEBOUNCE_SAMPLES; i++) {
    sum += sample_buffer[i];
  }

  // Return true only if all samples are HIGH
  return (sum == DEBOUNCE_SAMPLES);
}
```

**Duration Tracking:**
```cpp
uint32_t presence_start_time = 0;
uint8_t presence_duration = 0;  // Seconds

void updatePresenceDuration(bool presence_detected) {
  if (presence_detected) {
    if (presence_start_time == 0) {
      presence_start_time = millis();
    }
    presence_duration = (millis() - presence_start_time) / 1000;
    if (presence_duration > 255) presence_duration = 255;  // Cap at 255s
  } else {
    presence_start_time = 0;
    presence_duration = 0;
  }
}
```

**Event Counting:**
```cpp
bool previous_presence = false;
uint8_t event_count = 0;

void updateEventCount(bool current_presence) {
  // Detect rising edge
  if (current_presence && !previous_presence) {
    event_count++;
    if (event_count == 0) event_count = 255;  // Handle overflow
  }
  previous_presence = current_presence;
}
```

### I2C Register Map (Enhanced)

**Existing Registers (Epic 1):**
| Address | Access | Description |
|---------|--------|-------------|
| 0x00 | R | Module ID (0x08) |
| 0x01 | R | Firmware version |
| 0x02 | R | Status (READY/BUSY/ERROR) |
| 0x10 | W | Expression type (0-6) |
| 0x11 | W | Expression intensity (1-5) |
| 0x12 | W | Blink trigger |

**New Registers (This Story):**
| Address | Access | Description |
|---------|--------|-------------|
| 0x20 | R | Presence status (0=none, 1=detected) |
| 0x21 | R | Presence duration (0-255 seconds) |
| 0x22 | R | Event count (0-255) |
| 0x23 | R/W | Autonomous mode (0=off, 1=on) |

### Performance Considerations

**FPS Impact:**
- Presence polling: 20Hz = 50ms cycle time
- Eye rendering: 60 FPS = 16.7ms frame time
- Total overhead: <1ms per presence poll
- Impact on FPS: Negligible (use non-blocking code)

**Memory Usage:**
- Debounce buffer: 4 bytes
- Duration tracking: 8 bytes (uint32_t + uint8_t)
- Event count: 1 byte
- Total: <20 bytes additional RAM

**RTOS Considerations (ESP32):**
- Use FreeRTOS timer for 20Hz polling (non-blocking)
- Presence task runs on Core 1, eye rendering on Core 0
- Or use simple millis() timing in main loop

### Autonomous Reactions Design

**Use Case:**
- Person enters room → Olaf blinks (acknowledges presence)
- Provides "awareness" without orchestrator involvement
- Can be disabled for manual control mode

**Implementation:**
```cpp
if (autonomous_mode && presence_detected && rising_edge) {
  // Trigger blink internally
  triggerBlink();  // Calls existing blink logic from Epic 1
}
```

**Configuration via I2C:**
```bash
# Enable autonomous mode
sudo i2cset -y 1 0x08 0x23 1

# Disable autonomous mode
sudo i2cset -y 1 0x08 0x23 0
```

### Testing

**Basic Presence Test:**
```bash
# Read presence status
sudo i2cget -y 1 0x08 0x20  # Should return 0x00 (no presence) or 0x01 (detected)

# Read duration
sudo i2cget -y 1 0x08 0x21  # Seconds of continuous presence

# Read event count
sudo i2cget -y 1 0x08 0x22  # Number of presence events
```

**Debouncing Test:**
- Approach sensor slowly
- Verify presence status doesn't toggle until stable for 200ms
- Move hand rapidly in/out of detection zone
- Verify no false positives

**Autonomous Blink Test:**
```bash
# Enable autonomous mode
sudo i2cset -y 1 0x08 0x23 1

# Approach sensor → eyes should blink automatically
# Leave and re-approach → eyes blink again
```

**Performance Test:**
- Monitor serial output for FPS counter
- Verify 60 FPS maintained while presence polling active
- Check for frame drops or stuttering

**Troubleshooting:**
- **Presence always HIGH:** Check sensor wiring, verify 3.3V power
- **Presence always LOW:** Check GPIO16 connection, verify sensor powered
- **Noisy detection:** Increase debounce time (DEBOUNCE_SAMPLES)
- **FPS drops:** Reduce presence polling rate or optimize code
- **Autonomous blink not working:** Verify register 0x23 enabled, check rising edge detection

### File Locations

```
firmware/head/firmware/
├── src/
│   ├── main.cpp                    # <-- THIS STORY (update)
│   ├── presence_sensor.cpp         # <-- THIS STORY (new)
│   ├── eye_expression.cpp          # Existing (Epic 1)
│   ├── gc9a01_driver_spi.cpp       # Existing (Epic 1)
│   └── i2c_slave.cpp               # <-- THIS STORY (update registers)
├── include/
│   ├── presence_sensor.h           # <-- THIS STORY (new)
│   └── config.h                    # Update with GPIO16 definition
└── README.md                       # <-- THIS STORY (update)
```

## Dev Agent Record

### Agent Model Used
<!-- To be filled by dev agent -->

### Debug Log References
<!-- To be filled by dev agent -->

### Completion Notes List
<!-- To be filled by dev agent -->

### File List
<!-- To be filled by dev agent -->

## QA Results
<!-- To be filled by QA agent -->

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-08 | v1.0 | Initial story creation from Epic 3 | Sarah (Product Owner) |
